
use std::fs::File;
use std::io::{BufReader, BufRead, Error};
use std::{io, vec};
use std::thread::sleep;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

struct App {
    hangman_logo: Vec<String>,
}

impl App {
    fn new() -> Self {
        let path = "res/logo.txt".to_string();
        let file = File::open(path).expect("failed to open logo file");
        let reader = BufReader::new(file);
        let my_closure = |r: Result<String, Error>| {
            match r {
                Ok(line) => line,
                Err(err) =>  {
                    println!("We got an error: {err}");
                    "".to_string()
                },
            }
        };
        let hangman_logo: Vec<String> = reader.lines().map(my_closure).collect();
        Self { hangman_logo }
    } 

}

fn print_heart() {

    let path = "res/heart.txt".to_string();
    let file = File::open(path).expect("failed to open words file");
    let reader = BufReader::new(file);
    let argument = |r: Result<String, Error>| {
        match r {
            Ok(line) => line,
            Err(..) => { "".to_string() },
        }
    };
    let heart_logo: Vec<String> = reader.lines().map(argument).collect();
    for line in heart_logo.iter() {
        println!("{line}");
    }
    println!(" ");
}

fn ascii_arts(n: u8) {

    match n {

        // hangman 
        0 => print!("  +---+\n  |   |\n  O   |\n /|L  |\n  /L  |\n      |\n=========\n"),
        1 => print!("  +---+\n  |   |\n  O   |\n /|L  |\n  /   |\n      |\n=========\n"),
        2 => print!("  +---+\n  |   |\n  O   |\n /|L  |\n      |\n      |\n=========\n"),
        3 => print!("  +---+\n  |   |\n  O   |\n /|   |\n      |\n      |\n=========\n"),
        4 => print!("  +---+\n  |   |\n  O   |\n  |   |\n      |\n      |\n=========\n"),
        5 => print!("  +---+\n  |   |\n  O   |\n      |\n      |\n      |\n=========\n"),
        6 => print!("  +---+\n  |   |\n      |\n      |\n      |\n      |\n=========\n"),

        _ => println!("ascii animation not found"),
    }
}


fn current_display_state(attempts: &u8, player_guessed_chars: &String, thing_on_display: &Vec<char> ) {

    let a = attempts;
    let c = player_guessed_chars;
    let t = thing_on_display;

    println!("_______________________________________________________");
    print!("{a} remaining a | ");
    for _ in 0..*a {
        print!("<3 ");
    }
    println!("");
    ascii_arts(*a);
    println!("[ {c}]");
    println!(" ");
    println!("{}", t.iter().collect::<String>()); //iterator for underscore conversion
    println!(" ");
    //println!("Please input your guess:");
    for _n in 0..11 {
        println!("");
    }

}

fn heart_display_state(attempts: &u8, player_guessed_chars: &String, thing_on_display: &Vec<char> ) {

    let a = attempts;
    let c = player_guessed_chars;
    let t = thing_on_display;

    println!("_______________________________________________________");
    print!("{a} remaining a | ");
    for _ in 0..*a - 1 {
        print!("<3 ");
    }
    print!("██");
    println!("");
    ascii_arts(*a);
    println!("[ {c}]");
    println!(" ");
    println!("{}", t.iter().collect::<String>()); //iterator for underscore conversion
    println!(" ");
    //println!("Please input your guess:");
    for _n in 0..11 {
        println!("");
    }

}

fn clear_display() {
    for _ in 0..23 {
        println!(" ");
    }
}

fn heart_animation(a: &u8, c: &String, t: &Vec<char>) {
    
    heart_display_state(&a,&c,&t);   
    sleep(Duration::from_millis(500));
    clear_display();
    current_display_state(&a,&c,&t);
    sleep(Duration::from_millis(500));
    clear_display();

    heart_display_state(&a,&c,&t);   
    sleep(Duration::from_millis(500));
    clear_display();
    current_display_state(&a,&c,&t);
    clear_display();

}

fn lcg(n:u64) -> u64 {       

    // lcg parameters (from Wikipedia sourced by Numerical Recipes, seems to work fine)
    let m:u64 = u64::pow(2, 32); // modulus
    let a:u64 = 1664525; // multiplier
    let c:u64 = 1013904223; // increment

    // seed generated by current time 
    let time = SystemTime::now().duration_since(UNIX_EPOCH).expect("Time not found"); 
    let s: u64 = time.as_secs() as u64; // seed

    // somehow this crap works
    let mut current = s;
    for _ in 0..19 {
        current = (a * current + c) % m;
        //let result = current % n;         // used for debug to check for range & probability
        //println!("{}", result);

    }
    let result = current % n;

    result
}

// provides one word "randomly" from dictionary to game()
fn pvc_mode() {
    
    // Gets game dictionary into a vector
    let path = "res/words.txt".to_string();
    let file = File::open(path).expect("failed to open words file");
    let reader = BufReader::new(file);
    let argument = |r: Result<String, Error>| {
        match r {
            Ok(line) => line,
            Err(..) => { "".to_string() },
        }
    };

    // Game dictionary (to be somehow replaced by incorporating dictionary.txt)
    let dictionary: Vec<String> = reader.lines().map(argument).collect();
    
    // Random number provided by linear congruential generator
    let size = dictionary.len();
    let random_number = lcg(size as u64);
    //print!("THE RANDOM NUMBER IS: {} ", random_number); // for debug purposes

    // Number-to-guess conversion (to be modified once dictionary.txt is incorporated)
    let word_to_guess = dictionary[random_number as usize].to_lowercase(); 

    // game function
    game(word_to_guess);
    
}

// provides one word by user input to game()
fn pvp_mode() {
    
    // aesthethics
    println!("PLAYER ONE, PLEASE INPUT THE WORD TO BE GUESSED ");
    for _n in 0..19 {
        println!("");
    }

    // user input
    let mut _pvp_word = String::new();
    io::stdin().read_line(&mut _pvp_word).expect("Failed to read in your word");
    _pvp_word.pop();
    
    // aesthethics
    for _n in 0..29 {
        println!("");
    }
    println!("Player 2 shall start now!");
    for _n in 0..19 {
        println!("");
    }
    
    // game function
    game(_pvp_word.to_lowercase());
    
}

fn game(word_to_guess:String) {
    
    let mut thing_on_display = vec!['_'; word_to_guess.len()]; 
    let mut attempts = 6;
    let mut player_guessed_chars = String::new(); 
    
    while attempts > 0 {

        println!("_______________________________________________________");
        print!("{attempts} remaining a | ");
        for _ in 0..attempts {
            print!("<3 ");
        }
        println!("");
        ascii_arts(attempts);
        println!("[ {player_guessed_chars}]");
        println!(" ");
        println!("{}", thing_on_display.iter().collect::<String>()); //iterator for underscore conversion
        println!(" ");
        println!("Please input your guess:");
        for _n in 0..10 {
            println!("");
        }

        // reads in user guess
        let mut guess_input = String::new();
        io::stdin().read_line(&mut guess_input).expect("Failed to read in guess input");
        let guess = guess_input.trim().chars().next().unwrap(); // checks and trims for single char input

        // checks player input according to hangman rules
        if word_to_guess.contains(guess) {
            for _n in 0..19 {
                println!("");
            }
            for (i, c) in word_to_guess.chars().enumerate() { // replaces the underscores with guessed char
                if c == guess {
                    thing_on_display[i] = c;
                }
            }
            if !thing_on_display.contains(&'_') { // checks whether word has been found or not
                for _n in 0..19 {
                    println!("");
                }
                println!("Correct, the word was [ {word_to_guess} ]!");
                break;
            }
        } else {
            player_guessed_chars.push(guess);
            player_guessed_chars.push(' ');
            for _n in 0..19 {
                println!("");
            }
            heart_animation(&attempts, &player_guessed_chars, &thing_on_display);
            attempts -= 1;
            //if attempts > 0 {println!("False! Try again");}
        }
    }
    
    if attempts == 0 {
        ascii_arts(0);
        println!("Game over :( The word was: [ {word_to_guess} ]");
        println!(" ")
    }

}


fn main() {
    
    let app = App::new();

    for _ in 0..29 {
        println!(" ");
    }
    println!("Welcome to version 1.5!");
    for line in app.hangman_logo.iter() {
        println!("{line}");
    }
    println!(" ");
    println!("Please select a modi: ");
    println!(" ");
    println!("1 = Player Versus Computer");
    println!("2 = Player Versus Player");
    for _ in 0..10 {
        println!(" ");
        sleep(Duration::from_millis(50));
    }
    
    //user input read in
    let mut modi_input = String::new();
    io::stdin().read_line(&mut modi_input).expect("failed to read in user input");
    modi_input = modi_input.trim().to_string();

    if modi_input == "1" {
        clear_display();
        println!("You have selected: Player Versus Computer. The game starts now!");
        clear_display();
        sleep(Duration::from_millis(1000));
        println!("remember: please only input lowercase chars");
        clear_display();
        sleep(Duration::from_millis(2000));
        pvc_mode();
    } else if modi_input == "2" {
        clear_display();
        println!("You have selected: Player Versus Player. The game starts now!");
        clear_display();
        sleep(Duration::from_millis(1000));
        println!("remember: please only input lowercase chars");
        clear_display();
        sleep(Duration::from_millis(2000));
        pvp_mode();
    } else {
        println!("Failed to read in user input");
    }

    println!("Round ended, do you want to start a new round? [ y / n ]");
    let mut round_input = String::new();
    io::stdin().read_line(&mut round_input).expect("failed to read in user input");
    let char = round_input.trim().chars().next().unwrap();

    match char {

        'y' => main(),
        'n' => {
                clear_display();
                print_heart();
                println!("Thank you for testing Hangman! Until next time :)");
                println!(" ");
            },
        _ => println!("unvalid input"),

    }
    
}

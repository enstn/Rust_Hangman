
use std::io;
use std::thread::sleep;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

fn ascii_animations(n:u8) {
    match n {

        // hangman 
        0 => print!("  +---+\n  |   |\n  O   |\n /|L  |\n  /L  |\n      |\n=========\n"),
        1 => print!("  +---+\n  |   |\n  O   |\n /|L  |\n  /   |\n      |\n=========\n"),
        2 => print!("  +---+\n  |   |\n  O   |\n /|L  |\n      |\n      |\n=========\n"),
        3 => print!("  +---+\n  |   |\n  O   |\n /|   |\n      |\n      |\n=========\n"),
        4 => print!("  +---+\n  |   |\n  O   |\n  |   |\n      |\n      |\n=========\n"),
        5 => print!("  +---+\n  |   |\n  O   |\n      |\n      |\n      |\n=========\n"),
        6 => print!("  +---+\n  |   |\n      |\n      |\n      |\n      |\n=========\n"),

        // title
        7 =>  println!(r"██   ██  █████  ███    ██  ██████  ███    ███  █████  ███    ██"), 
        8 =>  println!(r"██   ██ ██   ██ ████   ██ ██       ████  ████ ██   ██ ████   ██"),
        9 =>  println!(r"███████ ███████ ██ ██  ██ ██   ███ ██ ████ ██ ███████ ██ ██  ██"),
        10 => println!(r"██   ██ ██   ██ ██  ██ ██ ██    ██ ██  ██  ██ ██   ██ ██  ██ ██"),
        11 => println!(r"██   ██ ██   ██ ██   ████  ██████  ██      ██ ██   ██ ██   ████"),

        _ => println!("ascii animation not found")

    }
}

fn lcg(n:u64) -> u64 {       

    // lcg parameters (from Wikipedia sourced by Numerical Recipes, seems to work fine)
    let m:u64 = u64::pow(2, 32); // modulus
    let a:u64 = 1664525; // multiplier
    let c:u64 = 1013904223; // increment

    // seed generated by current time 
    let time = SystemTime::now().duration_since(UNIX_EPOCH).expect("Time not found"); 
    let s: u64 = time.as_secs() as u64; // seed

    // somehow this crap works
    let mut current = s;
    for _ in 0..19 {
        current = (a * current + c) % m;
        //let result = current % n;         // used for debug to check for range & probability
        //println!("{}", result);

    }
    let result = current % n;


    result
}

// provides one word "randomly" from library to game()
fn pvc_mode() {

    // Game library (to be somehow replaced by incorporating library.txt)
    let library = vec!["Jazz", "Why", "Are", "You", "Gay"];
    
    // Random number provided by linear congruential generator
    let size = library.len();
    let random_number = lcg(size as u64);
    print!("THE RANDOM NUMBER IS: {} ", random_number);

    // Number-to-guess conversion (to be modified once library.txt is incorporated)
    let word_to_guess = library[random_number as usize].to_lowercase(); 

    // game function
    game(word_to_guess);
    
}

// provides one word by user input to game()
fn pvp_mode() {
    
    // aesthethics
    println!("Player One, please input the word to be guessed: ");
    for _n in 0..22 {
        println!("");
    }

    // user input
    let mut _pvp_word = String::new();
    io::stdin().read_line(&mut _pvp_word).expect("Failed to read in your word");
    _pvp_word.pop();
    
    // aesthethics
    for _n in 0..29 {
        println!("");
    }
    println!("Player 2 shall start now!");
    for _n in 0..19 {
        println!("");
    }
    
    // game function
    game(_pvp_word.to_lowercase());
    
}

fn game(word_to_guess:String) {
    
    let mut thing_on_display = vec!['_'; word_to_guess.len()]; 
    let mut attempts = 6;
    let mut player_guessed_chars = String::new(); 
    
    while attempts > 0 {

        println!("_______________________________________________________");
        ascii_animations(attempts);
        print!("You have {} remaining attempts.", attempts);
        println!(" Previously guessed characters: {}", player_guessed_chars);
        println!(" ");

        println!("{}", thing_on_display.iter().collect::<String>()); //iterator for underscore conversion

        println!(" ");
        println!("Please input your guess:");
        for _n in 0..10 {
            println!("");
        }
        
        // reads in user guess
        let mut guess_input = String::new();
        io::stdin().read_line(&mut guess_input).expect("Failed to read in guess input");
        let guess = guess_input.trim().chars().next().unwrap(); // checks and trims for single char input

        // checks player input according to hangman rules
        if word_to_guess.contains(guess) {
            for _n in 0..19 {
                println!("");
            }
            for (i, c) in word_to_guess.chars().enumerate() { // replaces the underscores with guessed char
                if c == guess {
                    thing_on_display[i] = c;
                }
            }
            if (!thing_on_display.contains(&'_')) { // checks whether word has been found or not
                for _n in 0..19 {
                    println!("");
                }
                println!("Correct, the word was [ {} ]!", word_to_guess);
                break;
            }
        } else {
            player_guessed_chars.push(guess);
            player_guessed_chars.push(' ');
            for _n in 0..19 {
                println!("");
            }
            attempts -= 1;
            if (attempts > 0) {println!("False! Try again");}
        }
    }
    
    if attempts == 0 {
        ascii_animations(0);
        println!("Game over :( The word was: [ {} ]", word_to_guess);
        println!(" ")
    }

}


fn main() {
    
    for _n in 0..29 {
        println!(" ");
    }
    println!("Welcome to version 1.4!"); 
    for n in 7..12 {
        ascii_animations(n);
        //sleep(Duration::from_millis(100));
    }
    println!(" ");
    println!("Please select a modi: ");
    println!(" ");
    println!("1 = Player Versus Computer");
    println!("2 = Player Versus Player");
    for _ in 0..10 {
        println!(" ");
        sleep(Duration::from_millis(50));
    }
    
    //user input read in
    let mut modi_input = String::new();
    io::stdin().read_line(&mut modi_input).expect("failed to read in user input");
    modi_input = modi_input.trim().to_string();

    if (modi_input == "1") {
        for _n in 0..49 {
            println!("");
        }
        println!("You have selected: Player Versus Computer. The game starts now!");
        pvc_mode();
    } else if (modi_input == "2") {
        for _n in 0..49 {
            println!("");
        }
        println!("You have selected: Player Versus Player. The game starts now!");
        pvp_mode();
    } else {
        println!("Failed to read in user input");
    }

    println!("Round ended, do you want to start a new round? [ y / n ]");
    let mut round_input = String::new();
    io::stdin().read_line(&mut round_input).expect("failed to read in user input");
    let char = round_input.trim().chars().next().unwrap();

    match char {

        'y' => main(),
        'n' => println!(""),
        _ => println!("unvalid input"),

    }

    println!("Thank you for playing Hangman! Until next time :)");
    for _n in 0..13 {
        println!("");
    }
    
}